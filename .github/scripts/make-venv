#! /usr/bin/env python3

"""
Create an isolated virtual environment for installation of Python packages.
Customized for our needs, relative to what the stock `python3 -m venv` does:

 - No command line options are available.  You always get the behavior
   of `python3 -m venv --clear <DIRECTORY>`.

 - Always creates a 'bin' directory containing the activation scripts
   and interpreter executables, never a 'Scripts' directory.

 - Always creates interpreter executables named 'python3' and 'python3.X'
   (where X is sys.version_info[1]).

 - Also always creates a 'python' executable in the bin directory, but
   it's a stub that prints an error message and exits unsuccessfully.
   (This is because 'python' should never be used by Python 3
   programs; that name is properly left reserved for a Python 2
   interpreter.  Our code is strictly Python 3 and so should not use
   it, but the base system might, incorrectly, provide a Python 3
   interpreter under that name, potentially masking bugs.)

 - Backported a bugfix in the Bourne-shell activation script from
   the Python 3.12 venv module.

 - Activation scripts do not provide "deactivate" and do not modify the
   prompt, since we only ever use these venvs in automated builds that
   don't need those features.

"""


import argparse
import os
import stat
import subprocess
import sys
import venv


BAT_ACTIVATE = """\
@echo off
set VIRTUAL_ENV={__VENV_DIR__}
set PYTHONHOME=

if defined _OLD_VIRTUAL_PATH set PATH=%_OLD_VIRTUAL_PATH%
if not defined _OLD_VIRTUAL_PATH set _OLD_VIRTUAL_PATH=%PATH%
set PATH=%VIRTUAL_ENV%\\{__VENV_BIN_NAME__};%PATH%
"""

BAT_PYTHON2_STUB = """\
@echo "%0: error: Python 2 interpreter not available." >&2
@exit 1
"""

SH_ACTIVATE = """\
# on Windows, a path can contain colons and backslashes and has to be converted:
if [ "${{OSTYPE:-}}" = "cygwin" ] || [ "${{OSTYPE:-}}" = "msys" ] ; then
    # transform D:\\path\\to\\venv to /d/path/to/venv on MSYS
    # and to /cygdrive/d/path/to/venv on Cygwin
    export VIRTUAL_ENV=$(cygpath "{__VENV_DIR__}")
else
    # use the path as-is
    export VIRTUAL_ENV="{__VENV_DIR__}"
fi

if [ -n "${{_OLD_VIRTUAL_PATH:-}}" ] ; then
    PATH="${{_OLD_VIRTUAL_PATH:-}}"
fi
_OLD_VIRTUAL_PATH="$PATH"
export PATH="$VIRTUAL_ENV/{__VENV_BIN_NAME__}:$PATH"

unset PYTHONHOME
unset _OLD_VIRTUAL_PYTHONHOME
unset VIRTUAL_ENV_PROMPT

hash -r 2> /dev/null
"""

SH_PYTHON2_STUB = """\
#! /bin/sh
echo "$0: error: Python 2 interpreter not available." >&2
exit 1
"""


def require_regular_file(path):
    """Raise an exception if PATH does not exist or is not a regular
       file or a symlink to a regular file, being specific about what
       the issue is.
    """
    def describe_filetype(mode):
        if stat.S_ISREG(mode):
            return "a file"
        if stat.S_ISDIR(mode):
            return "a directory"
        if stat.S_ISLNK(mode):
            return "a symlink"
        if stat.S_ISSOCK(mode):
            return "a socket"
        if stat.S_ISFIFO(mode):
            return "a named pipe"
        if stat.S_ISCHR(mode):
            return "a character device"
        if stat.S_ISBLK(mode):
            return "a block device"
        if stat.S_ISDOOR(mode):
            return "a door"
        if stat.S_ISPORT(mode):
            return "an event port"
        if stat.S_ISWHT(mode):
            return "a whiteout"
        return f"something strange (format code 0x{stat.S_IFMT(mode):4x})"

    def describe_non_file(path, mode_or_error,
                          path2=None, mode2_or_error=None):
        if isinstance(mode_or_error, FileNotFoundError):
            return f"{path!r} doesn't exist"
        if isinstance(mode2_or_error, OSError):
            return f"{path!r} is inaccessible: {mode_or_error.strerror}"

        what = describe_filetype(mode_or_error)
        if what == "a file":
            raise ValueError("describe_non_file called on a file")
        if what != "a symlink":
            return f"{path!r} is {what}, not a file"

        if isinstance(mode2_or_error, FileNotFoundError):
            return f"{path!r} is a symlink to {path2!r} which doesn't exist"

        if isinstance(mode2_or_error, OSError):
            return (
                f"{path!r} is a symlink to {path2!r}"
                f" which is inaccessible: {mode2_or_error.strerror}"
            )

        what2 = describe_filetype(mode2)
        if what2 == "a file":
            raise ValueError("describe_non_file called on a symlink to a file")
        return (
            f"{path!r} is a symlink to {path2!r} which is {what2}, not a file"
        )

    try:
        st = os.lstat(path)
    except OSError as e:
        raise RuntimeError(describe_non_file(path, e)) from e

    if stat.S_ISREG(st.st_mode):
        return
    if not stat.S_ISLNK(st.st_mode):
        raise RuntimeError(describe_non_file(path, st.st_mode))

    target = os.readlink(path)
    try:
        tst = os.stat(path)
    except OSError as e:
        raise RuntimeError(describe_non_file(
            path, st.st_mode, target, e
        )) from e

    if not stat.S_ISREG(tst.st_mode):
        raise RuntimeError(describe_non_file(
            path, st.st_mode, target, tst.st_mode
        ))


class CustomEnvBuilder(venv.EnvBuilder):
    def __init__(self):
        super().__init__(
            clear=True,
            symlinks = (os.name != 'nt'),
            system_site_packages=False,
            upgrade=False,
            upgrade_deps=False,
            with_pip=True,
        )

    def ensure_directories(self, env_dir):
        sys.stderr.write("creating directories...\n")
        env_dir = os.path.normcase(os.path.realpath(env_dir))
        context = super().ensure_directories(env_dir)

        # we always want <env>/bin, not <env>/scripts
        if context.bin_name != "bin":
            corrected_bin_path = os.path.join(context.env_dir, 'bin')
            os.rename(context.bin_path, corrected_bin_path)

            context.bin_name = "bin"
            context.bin_path = corrected_bin_path

        # no matter what the interpreter is called outside the environment,
        # it should be called 'python3' inside the environment
        if context.python_exe.endswith(".exe"):
            context.env_exe = os.path.join(context.bin_path, "python3.exe")
        else:
            context.env_exe = os.path.join(context.bin_path, "python3")

        # duplicate the fix for bpo-45337
        if sys.platform == "win32":
            context.env_exec_cmd = os.path.normcase(
                os.path.realpath(context.env_exe)
            )
        else:
            context.env_exec_cmd = context.env_exe

        return context

    def setup_python(self, context):
        sys.stderr.write("setting up python...\n")
        super().setup_python(context)
        for unwanted in ['python', 'python.exe', 'python_d.exe',
                         'pythonw.exe', 'pythonw_d.exe']:
            try:
                os.remove(os.path.join(context.bin_path, unwanted))
            except FileNotFoundError:
                pass
        require_regular_file(context.env_exe)
        if context.env_exec_cmd != context.env_exec_cmd:
            require_regular_file(context.env_exec_cmd)

        if os.name == 'nt':
            python3x = f'python3.{sys.version_info[1]}.exe'
            python2 = 'python.bat'
            python2_stub = BAT_PYTHON2_STUB
            do_chmod = False
        else:
            python3x = f'python3.{sys.version_info[1]}'
            python2 = 'python'
            python2_stub = SH_PYTHON2_STUB
            do_chmod = True

        python3x = os.path.join(context.bin_path, python3x)
        python2 = os.path.join(context.bin_path, python2)

        if not os.path.exists(python3x):
            self.symlink_or_copy(context.env_exe, python3x,
                                 relative_symlinks_ok=True)

        with open(python2, "xt") as fp:
            fp.write(python2_stub)
        if do_chmod:
            os.chmod(python2, 0o755)

    def _setup_pip(self, context):
        # differences from base class:
        # - bug fix for gh-98251 backported from 3.11
        # - don't swallow the output from the command

        # gh-98251: We do not want to just use '-I' because that masks
        # legitimate user preferences (such as not writing bytecode). All we
        # really need is to ensure that the path variables do not overrule
        # normal venv handling.
        kwargs = {}
        kwargs['env'] = env = os.environ.copy()
        env['VIRTUAL_ENV'] = context.env_dir
        env.pop('PYTHONHOME', None)
        env.pop('PYTHONPATH', None)
        kwargs['cwd'] = context.env_dir
        kwargs['executable'] = context.env_exec_cmd
        subprocess.check_call([
            context.env_exec_cmd,
            "-Im", "ensurepip", "--upgrade", "--default-pip"
        ], **kwargs)

    def setup_scripts(self, context):
        sys.stderr.write("setting up scripts...\n")
        # always install the sh activation script; on windows also
        # install the batch file
        scripts = [("activate", SH_ACTIVATE)]
        if os.name == 'nt':
            scripts.append(("activate.bat", BAT_ACTIVATE))

        for name, contents in scripts:
            path = os.path.join(context.bin_path, name)
            with open(path, "xt") as fp:
                fp.write(contents.format(
                    __VENV_DIR__ = context.env_dir,
                    __VENV_BIN_NAME__ = context.bin_name,
                ))


def main():
    ap = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    ap.add_argument("dir", help="Directory to create the environment in.")
    args = ap.parse_args()

    CustomEnvBuilder().create(args.dir)
    sys.stderr.write("done\n")
    sys.exit(0)


main()

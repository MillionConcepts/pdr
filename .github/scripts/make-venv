#! /usr/bin/env python3

"""
Create an isolated virtual environment for installation of Python packages.
Customized for our needs, relative to what the stock `python3 -m venv` does:

 - No command line options are available.  You always get the behavior
   of `python3 -m venv --clear <DIRECTORY>`.

 - Always creates interpreter executables named 'python3' and 'python3.X'
   (where X is sys.version_info[1]).

 - Also always creates a 'python' executable in the bin directory, but
   it's a stub that prints an error message and exits unsuccessfully.
   (This is because 'python' should never be used by Python 3
   programs; that name is properly left reserved for a Python 2
   interpreter.  Our code is strictly Python 3 and so should not use
   it, but the base system might, incorrectly, provide a Python 3
   interpreter under that name, potentially masking bugs.)

 - Backported a bugfix in the Bourne-shell activation script from Python 3.12.

 - Backported a bugfix in the invocation of ensurepip from Python 3.11.

 - Activation scripts do not provide "deactivate" and do not modify the
   prompt, since we only ever use these venvs in automated builds that
   don't need those features.
"""


import argparse
import glob
import os
import stat
import subprocess
import sys
import venv


BAT_ACTIVATE = """\
@echo off
set VIRTUAL_ENV={__VENV_DIR__}
set PYTHONHOME=

if defined _OLD_VIRTUAL_PATH set PATH=%_OLD_VIRTUAL_PATH%
if not defined _OLD_VIRTUAL_PATH set _OLD_VIRTUAL_PATH=%PATH%
set PATH=%VIRTUAL_ENV%\\{__VENV_BIN_NAME__};%PATH%
"""

BAT_PYTHON2_STUB = """\
@echo "%0: error: Python 2 interpreter not available." >&2
@exit 1
"""

SH_ACTIVATE = """\
# on Windows, a path can contain colons and backslashes and has to be converted:
if [ "${{OSTYPE:-}}" = "cygwin" ] || [ "${{OSTYPE:-}}" = "msys" ] ; then
    # transform D:\\path\\to\\venv to /d/path/to/venv on MSYS
    # and to /cygdrive/d/path/to/venv on Cygwin
    export VIRTUAL_ENV=$(cygpath "{__VENV_DIR__}")
else
    # use the path as-is
    export VIRTUAL_ENV="{__VENV_DIR__}"
fi

if [ -n "${{_OLD_VIRTUAL_PATH:-}}" ] ; then
    PATH="${{_OLD_VIRTUAL_PATH:-}}"
fi
_OLD_VIRTUAL_PATH="$PATH"
export PATH="$VIRTUAL_ENV/{__VENV_BIN_NAME__}:$PATH"

unset PYTHONHOME
unset _OLD_VIRTUAL_PYTHONHOME
unset VIRTUAL_ENV_PROMPT

hash -r 2> /dev/null
"""

SH_PYTHON2_STUB = """\
#! /bin/sh
echo "$0: error: Python 2 interpreter not available." >&2
exit 1
"""


def require_regular_file(path):
    """Raise an exception if PATH does not exist or is not a regular
       file or a symlink to a regular file, being specific about what
       the issue is.
    """
    def describe_filetype(mode):
        if stat.S_ISREG(mode):
            return "a file"
        if stat.S_ISDIR(mode):
            return "a directory"
        if stat.S_ISLNK(mode):
            return "a symlink"
        if stat.S_ISSOCK(mode):
            return "a socket"
        if stat.S_ISFIFO(mode):
            return "a named pipe"
        if stat.S_ISCHR(mode):
            return "a character device"
        if stat.S_ISBLK(mode):
            return "a block device"
        if stat.S_ISDOOR(mode):
            return "a door"
        if stat.S_ISPORT(mode):
            return "an event port"
        if stat.S_ISWHT(mode):
            return "a whiteout"
        return f"something strange (format code 0x{stat.S_IFMT(mode):4x})"

    def describe_non_file(path, mode_or_error,
                          path2=None, mode2_or_error=None):
        if isinstance(mode_or_error, FileNotFoundError):
            return f"{path!r} doesn't exist"
        if isinstance(mode2_or_error, OSError):
            return f"{path!r} is inaccessible: {mode_or_error.strerror}"

        what = describe_filetype(mode_or_error)
        if what == "a file":
            raise ValueError("describe_non_file called on a file")
        if what != "a symlink":
            return f"{path!r} is {what}, not a file"

        if isinstance(mode2_or_error, FileNotFoundError):
            return f"{path!r} is a symlink to {path2!r} which doesn't exist"

        if isinstance(mode2_or_error, OSError):
            return (
                f"{path!r} is a symlink to {path2!r}"
                f" which is inaccessible: {mode2_or_error.strerror}"
            )

        what2 = describe_filetype(mode2)
        if what2 == "a file":
            raise ValueError("describe_non_file called on a symlink to a file")
        return (
            f"{path!r} is a symlink to {path2!r} which is {what2}, not a file"
        )

    try:
        st = os.lstat(path)
    except OSError as e:
        raise RuntimeError(describe_non_file(path, e)) from e

    if stat.S_ISREG(st.st_mode):
        return
    if not stat.S_ISLNK(st.st_mode):
        raise RuntimeError(describe_non_file(path, st.st_mode))

    target = os.readlink(path)
    try:
        tst = os.stat(path)
    except OSError as e:
        raise RuntimeError(describe_non_file(
            path, st.st_mode, target, e
        )) from e

    if not stat.S_ISREG(tst.st_mode):
        raise RuntimeError(describe_non_file(
            path, st.st_mode, target, tst.st_mode
        ))


class CustomEnvBuilder(venv.EnvBuilder):
    def __init__(self):
        super().__init__(
            clear=True,
            symlinks = (os.name != 'nt'),
            system_site_packages=False,
            upgrade=False,
            upgrade_deps=False,
            with_pip=True,
        )

    def setup_python(self, context):
        sys.stderr.write("setting up python...\n")
        super().setup_python(context)

        P = os.path
        if os.name == 'nt':
            # On Windows, *only* context.bin_path / "python.exe" can
            # be trusted to exist and to work.  If any other
            # pythonXXX.exe files exist, they probably don't work;
            # specifically, they probably crash on startup due to
            # looking for essential DLLs in the wrong place.
            # See https://github.com/pyenv-win/pyenv-win/issues/490
            # for gory details.  Delete the broken executables, then
            # rename "python.exe" to "python3.exe", copy it to
            # "python3.X.exe", and fix up the context accordingly.
            pythons = glob.glob(P.join(context.bin_path, "python*.exe"))
            the_good_one = None
            for p in pythons:
                if p.endswith("/python.exe") or p.endswith("\\python.exe"):
                    the_good_one = p
                    continue
                os.remove(p)

            require_regular_file(the_good_one)

            desired_path = P.join(context.bin_path, "python3.exe")
            os.rename(the_good_one, desired_path)
            versioned_path = P.join(context.bin_path,
                                          f"python3.{sys.version_info[1]}.exe")
            self.symlink_or_copy(desired_path, versioned_path,
                                 relative_symlinks_ok=True)


            context.env_exe = desired_path
            # bpo-45337
            context.env_exec_cmd = P.normcase(
                P.realpath(context.env_exe)
            )

            masked_path = P.join(context.bin_path, "python.bat")
            with open(masked_path, "xt") as fp:
                fp.write(BAT_PYTHON2_STUB)

        else:
            pythons = glob.glob(P.join(context.bin_path, "python*"))
            # On non-Windows platforms, what we need to find is the
            # name matching the above glob that is either a regular file
            # or a symlink to somewhere outside the venv root.
            # That's the one that should be renamed to "python3" if it isn't
            # already.
            the_good_one = None
            for p in pythons:
                if the_good_one is not None:
                    os.remove(p)
                else:
                    st = os.lstat(p)
                    if stat.S_ISREG(st.st_mode):
                        the_good_one = p
                        continue
                    if stat.S_ISLNK(st.st_mode):
                        dest = P.realpath(P.join(
                            context.bin_path,
                            os.readlink(p)
                        ))
                        if P.relpath(dest, context.env_dir).startswith("../"):
                            the_good_one = p
                            continue
                    os.remove(p)

            desired_path = P.join(context.bin_path, "python3")
            os.rename(the_good_one, desired_path)
            versioned_path = P.join(context.bin_path,
                                    f"python3.{sys.version_info[1]}")
            self.symlink_or_copy(desired_path, versioned_path,
                                 relative_symlinks_ok=True)

            context.env_exe = desired_path
            context.env_exec_cmd = desired_path

            masked_path = P.join(context.bin_path, "python")
            with open(masked_path, "xt") as fp:
                fp.write(SH_PYTHON2_STUB)
            os.chmod(masked_path, 0o755)

    def _setup_pip(self, context):
        # differences from base class:
        # - bug fix for gh-98251 backported from 3.11
        # - don't swallow the output from the command

        # gh-98251: We do not want to just use '-I' because that masks
        # legitimate user preferences (such as not writing bytecode). All we
        # really need is to ensure that the path variables do not overrule
        # normal venv handling.
        kwargs = {}
        kwargs['env'] = env = os.environ.copy()
        env['VIRTUAL_ENV'] = context.env_dir
        env.pop('PYTHONHOME', None)
        env.pop('PYTHONPATH', None)
        kwargs['cwd'] = context.env_dir
        kwargs['executable'] = context.env_exec_cmd
        subprocess.check_call([
            context.env_exec_cmd,
            "-m", "ensurepip", "--upgrade", "--default-pip"
        ], **kwargs)

    def _install_scripts_in_dir(self, context, scripts, dir):
        os.makedirs(dir, exist_ok=True)
        for name, contents in scripts:
            path = os.path.join(dir, name)
            with open(path, "xt") as fp:
                fp.write(contents.format(
                    __VENV_DIR__ = context.env_dir,
                    __VENV_BIN_NAME__ = context.bin_name,
                ))

    def setup_scripts(self, context):
        sys.stderr.write("setting up scripts...\n")
        # always install the sh activation script; on windows also
        # install the batch file
        scripts = [("activate", SH_ACTIVATE)]
        if os.name == 'nt':
            scripts.append(("activate.bat", BAT_ACTIVATE))

        self._install_scripts_in_dir(context, scripts, context.bin_path)
        if not context.bin_path.endswith("bin"):
            # Also install the scripts in "bin" for the sake of being
            # able to do "source venv/bin/activate" regardless of whether
            # we are on Windows.
            self._install_scripts_in_dir(context, scripts,
                                         os.path.join(context.env_dir, "bin"))


def main():
    ap = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    ap.add_argument("dir", help="Directory to create the environment in.")
    args = ap.parse_args()

    CustomEnvBuilder().create(args.dir)
    sys.stderr.write("done\n")
    sys.exit(0)


main()
